'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const log4js = require('log4js');
const logger = log4js.getLogger('flowSaver');
const path = require('path');
appRequire('plugins/flowSaver/server');
appRequire('plugins/flowSaver/flow');
appRequire('plugins/flowSaver/generateFlow');
const cron = appRequire('init/cron');
const knex = appRequire('init/knex').knex;
const manager = appRequire('services/manager');
const moment = require('moment');
const minute = 1;
const time = minute * 60 * 1000;

let accountInfo = {};

const updateAccountInfo = (() => {
  var _ref = _asyncToGenerator(function* () {
    const accounts = yield knex('account_plugin').select().where({});
    accountInfo = {};
    accounts.forEach(function (account) {
      accountInfo[account.port] = account.id;
    });
    return;
  });

  return function updateAccountInfo() {
    return _ref.apply(this, arguments);
  };
})();

const saveFlow = (() => {
  var _ref2 = _asyncToGenerator(function* () {
    try {
      const servers = yield knex('server').select(['id', 'name', 'host', 'port', 'password', 'shift']);
      yield updateAccountInfo();
      const promises = [];
      const saveServerFlow = (() => {
        var _ref3 = _asyncToGenerator(function* (server) {
          const lastestFlow = yield knex('saveFlow').select(['time']).where({
            id: server.id
          }).orderBy('time', 'desc').limit(1);
          if (lastestFlow.length === 0 || Date.now() - lastestFlow[0].time >= time) {
            const options = {
              clear: true
            };
            let flow = yield manager.send({
              command: 'flow',
              options
            }, {
              host: server.host,
              port: server.port,
              password: server.password
            });
            flow = flow.map(function (f) {
              return {
                id: server.id,
                accountId: accountInfo[f.port - server.shift] || 0,
                port: f.port,
                flow: f.sumFlow,
                time: Date.now()
              };
            }).filter(function (f) {
              return f.flow > 0;
            });
            if (flow.length === 0) {
              return;
            }
            const insertPromises = [];
            for (let i = 0; i < Math.ceil(flow.length / 50); i++) {
              const insert = knex('saveFlow').insert(flow.slice(i * 50, i * 50 + 50));
              insertPromises.push(insert);
            }
            yield Promise.all(insertPromises);
          }
        });

        return function saveServerFlow(_x) {
          return _ref3.apply(this, arguments);
        };
      })();
      servers.forEach(function (server) {
        promises.push(saveServerFlow(server));
      });
      yield Promise.all(promises);
    } catch (err) {
      logger.error(err);
      return;
    }
  });

  return function saveFlow() {
    return _ref2.apply(this, arguments);
  };
})();

cron.minute(() => {
  saveFlow();
}, 1);